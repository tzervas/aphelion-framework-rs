"""Type stubs for aphelion Python bindings."""

from typing import Any, Callable, Optional, Sequence

# Version
__version__: str

# Feature flags
HAS_BURN: bool
HAS_CUBECL: bool
HAS_RUST_AI_CORE: bool
HAS_TRITTER_ACCEL: bool

# Configuration
class ModelConfig:
    name: str
    version: str
    params: dict[str, Any]
    
    def __init__(self, name: str, version: str) -> None: ...
    def with_param(self, key: str, value: Any) -> ModelConfig: ...
    def param(self, key: str) -> Any | None: ...
    def param_or(self, key: str, default: Any) -> Any: ...
    
    @staticmethod
    def small_preset(name: str, version: str) -> ModelConfig: ...
    @staticmethod
    def medium_preset(name: str, version: str) -> ModelConfig: ...
    @staticmethod
    def large_preset(name: str, version: str) -> ModelConfig: ...

class ModelConfigBuilder:
    def __init__(self) -> None: ...
    def name(self, name: str) -> ModelConfigBuilder: ...
    def version(self, version: str) -> ModelConfigBuilder: ...
    def param(self, key: str, value: Any) -> ModelConfigBuilder: ...
    def build(self) -> ModelConfig: ...

# Graph
class NodeId:
    value: int
    
    def __init__(self, value: int) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: NodeId) -> bool: ...
    def __int__(self) -> int: ...

class GraphNode:
    id: NodeId
    name: str
    config: ModelConfig
    metadata: dict[str, Any]
    
    def __init__(self, id: NodeId, name: str, config: ModelConfig) -> None: ...
    def with_metadata(self, key: str, value: Any) -> GraphNode: ...

class BuildGraph:
    nodes: list[GraphNode]
    edges: list[tuple[NodeId, NodeId]]
    
    def __init__(self) -> None: ...
    def add_node(self, name: str, config: ModelConfig) -> NodeId: ...
    def add_edge(self, from_id: NodeId, to_id: NodeId) -> None: ...
    def node_count(self) -> int: ...
    def edge_count(self) -> int: ...
    def has_cycle(self) -> bool: ...
    def topological_sort(self) -> list[NodeId]: ...
    def stable_hash(self) -> str: ...
    def to_dot(self) -> str: ...
    def __len__(self) -> int: ...
    def __bool__(self) -> bool: ...

# Backend
class MemoryInfo:
    total_bytes: int
    available_bytes: int

class DeviceCapabilities:
    supports_f16: bool
    supports_bf16: bool
    supports_f64: bool
    supports_int8: bool
    max_batch_size: int | None
    memory: MemoryInfo | None

class NullBackend:
    name: str
    device: str
    
    def __init__(self) -> None: ...
    @staticmethod
    def cpu() -> NullBackend: ...
    def is_available(self) -> bool: ...
    def capabilities(self) -> DeviceCapabilities: ...
    def initialize(self) -> None: ...
    def shutdown(self) -> None: ...

# Diagnostics
class TraceLevel:
    Debug: TraceLevel
    Info: TraceLevel
    Warn: TraceLevel
    Error: TraceLevel

class TraceEvent:
    id: str
    message: str
    level: TraceLevel
    span_id: str | None
    trace_id: str | None
    timestamp_secs: float
    
    def __init__(
        self,
        id: str,
        message: str,
        level: TraceLevel | None = None,
        span_id: str | None = None,
        trace_id: str | None = None,
    ) -> None: ...

class InMemoryTraceSink:
    def __init__(self) -> None: ...
    def record(self, event: TraceEvent) -> None: ...
    def events(self) -> list[TraceEvent]: ...
    def __len__(self) -> int: ...

class TraceFilter:
    def __init__(self, min_level: TraceLevel) -> None: ...
    def allows(self, event: TraceEvent) -> bool: ...

class MultiSink:
    def __init__(self) -> None: ...
    def add_sink(self, sink: Any) -> None: ...
    def record(self, event: TraceEvent) -> None: ...

# Pipeline
class BuildContext:
    def __init__(self, backend: Any, trace: InMemoryTraceSink) -> None: ...
    @staticmethod
    def with_null_backend() -> BuildContext: ...

class BuildPipeline:
    def __init__(self) -> None: ...
    @staticmethod
    def standard() -> BuildPipeline: ...
    @staticmethod
    def for_training() -> BuildPipeline: ...
    @staticmethod
    def for_inference() -> BuildPipeline: ...
    def with_stage(self, name: str, callback: Callable[[BuildGraph], BuildGraph | None]) -> BuildPipeline: ...
    def with_pre_hook(self, callback: Callable[[str, BuildGraph], None]) -> BuildPipeline: ...
    def with_post_hook(self, callback: Callable[[str, BuildGraph], None]) -> BuildPipeline: ...
    def with_skip_stage(self, stage_name: str) -> BuildPipeline: ...
    def with_progress(self, callback: Callable[[str, int, int], None]) -> BuildPipeline: ...
    def execute(self, ctx: BuildContext, graph: BuildGraph) -> BuildGraph: ...
    async def execute_async(self, ctx: BuildContext, graph: BuildGraph) -> BuildGraph: ...
    def __len__(self) -> int: ...

class ValidationStage:
    name: str
    def __init__(self) -> None: ...

class HashingStage:
    name: str
    def __init__(self) -> None: ...

# Validation
class ValidationError:
    field: str
    message: str
    details: str | None
    
    def __init__(self, field: str, message: str) -> None: ...
    def with_details(self, details: str) -> ValidationError: ...

class NameValidator:
    def __init__(self) -> None: ...
    def validate(self, config: ModelConfig) -> list[ValidationError]: ...

class VersionValidator:
    def __init__(self) -> None: ...
    def validate(self, config: ModelConfig) -> list[ValidationError]: ...

class CompositeValidator:
    def __init__(self) -> None: ...
    def with_name_validator(self) -> CompositeValidator: ...
    def with_version_validator(self) -> CompositeValidator: ...
    def validate(self, config: ModelConfig) -> list[ValidationError]: ...

# Export
class SerializableTraceEvent:
    id: str
    message: str
    timestamp: str
    level: str
    span_id: str | None
    trace_id: str | None
    
    def __init__(self, event: TraceEvent) -> None: ...

class JsonExporter:
    def __init__(self) -> None: ...
    def record(self, event: TraceEvent) -> None: ...
    def to_json(self) -> str: ...
    def to_json_pretty(self) -> str: ...
    def write_to(self, path: str) -> None: ...
    def __len__(self) -> int: ...

# Exceptions
class AphelionException(Exception): ...
class ConfigError(AphelionException): ...
class BackendError(AphelionException): ...
class BuildError(AphelionException): ...
class SerializationError(AphelionException): ...
class IoError(AphelionException): ...
class GraphError(AphelionException): ...

# Feature-gated types (may not be available)
class BurnDevice:
    @staticmethod
    def cpu() -> BurnDevice: ...
    @staticmethod
    def cuda(index: int) -> BurnDevice: ...
    def as_label(self) -> str: ...
    def is_cpu(self) -> bool: ...
    def is_gpu(self) -> bool: ...

class BurnBackendConfig:
    def __init__(self, device: BurnDevice) -> None: ...
    @staticmethod
    def cpu() -> BurnBackendConfig: ...
    @staticmethod
    def cuda(index: int) -> BurnBackendConfig: ...
    def with_tf32(self, enabled: bool) -> BurnBackendConfig: ...

class BurnBackend:
    name: str
    device: str
    
    def __init__(self, config: BurnBackendConfig) -> None: ...
    @staticmethod
    def cpu() -> BurnBackend: ...
    @staticmethod
    def cuda(index: int) -> BurnBackend: ...
    def is_available(self) -> bool: ...
    def capabilities(self) -> DeviceCapabilities: ...
    def initialize(self) -> None: ...
    def shutdown(self) -> None: ...

class CubeclDevice:
    @staticmethod
    def cpu() -> CubeclDevice: ...
    @staticmethod
    def cuda(index: int) -> CubeclDevice: ...
    @staticmethod
    def metal(index: int) -> CubeclDevice: ...
    @staticmethod
    def vulkan(index: int) -> CubeclDevice: ...
    @staticmethod
    def wgpu(index: int) -> CubeclDevice: ...
    def as_label(self) -> str: ...
    def is_cpu(self) -> bool: ...
    def is_gpu(self) -> bool: ...

class CubeclBackendConfig:
    def __init__(self, device: CubeclDevice) -> None: ...
    @staticmethod
    def cpu() -> CubeclBackendConfig: ...
    @staticmethod
    def cuda(index: int) -> CubeclBackendConfig: ...
    @staticmethod
    def metal(index: int) -> CubeclBackendConfig: ...
    @staticmethod
    def vulkan(index: int) -> CubeclBackendConfig: ...
    @staticmethod
    def wgpu(index: int) -> CubeclBackendConfig: ...
    def with_memory_fraction(self, fraction: float) -> CubeclBackendConfig: ...

class CubeclBackend:
    name: str
    device: str
    
    def __init__(self, config: CubeclBackendConfig) -> None: ...
    @staticmethod
    def cpu() -> CubeclBackend: ...
    @staticmethod
    def cuda(index: int) -> CubeclBackend: ...
    @staticmethod
    def metal(index: int) -> CubeclBackend: ...
    @staticmethod
    def vulkan(index: int) -> CubeclBackend: ...
    @staticmethod
    def wgpu(index: int) -> CubeclBackend: ...
    def is_available(self) -> bool: ...
    def capabilities(self) -> DeviceCapabilities: ...
    def initialize(self) -> None: ...
    def shutdown(self) -> None: ...

class TriterDevice:
    @staticmethod
    def cpu() -> TriterDevice: ...
    @staticmethod
    def cuda(index: int) -> TriterDevice: ...
    @staticmethod
    def metal(index: int) -> TriterDevice: ...
    def as_str(self) -> str: ...

class TrainingConfig:
    def __init__(self) -> None: ...
    def with_mixed_precision(self, enabled: bool) -> TrainingConfig: ...
    def with_gradient_checkpointing(self, enabled: bool) -> TrainingConfig: ...
    def with_seed(self, seed: int) -> TrainingConfig: ...

class InferenceConfig:
    def __init__(self) -> None: ...
    def with_batch_size(self, size: int) -> InferenceConfig: ...
    def with_kv_cache(self, enabled: bool) -> InferenceConfig: ...
    def without_ternary_quantization(self) -> InferenceConfig: ...

class AccelerationMode:
    @staticmethod
    def none() -> AccelerationMode: ...
    @staticmethod
    def training(config: TrainingConfig) -> AccelerationMode: ...
    @staticmethod
    def inference(config: InferenceConfig) -> AccelerationMode: ...

class TriterAccelBackend:
    name: str
    device: str
    
    def __init__(self, device: TriterDevice) -> None: ...
    @staticmethod
    def cpu() -> TriterAccelBackend: ...
    @staticmethod
    def cuda(index: int) -> TriterAccelBackend: ...
    @staticmethod
    def metal(index: int) -> TriterAccelBackend: ...
    def with_training_mode(self) -> TriterAccelBackend: ...
    def with_training_config(self, config: TrainingConfig) -> TriterAccelBackend: ...
    def with_inference_mode(self) -> TriterAccelBackend: ...
    def with_inference_config(self, config: InferenceConfig) -> TriterAccelBackend: ...
    def is_available(self) -> bool: ...
    def capabilities(self) -> DeviceCapabilities: ...
    def initialize(self) -> None: ...
    def shutdown(self) -> None: ...
